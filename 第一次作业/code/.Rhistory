i])))
}
alpha = eigen(M)$vector
fixq <- function(eigenvalue, n, p) {
cn = 1 / n ^ (1 / 3)
t = rep(0, p - 1)
q_hat = 0
for (i in 1:(p - 1)) {
if ((eigenvalue[i + 1] + cn) / (eigenvalue[i] + cn) <= 0.5)
{
q_hat = i
}
}
return(q_hat)
}
q_hat = fixq(eigen(M)$value, n, p)
beta_hat = sd %*% alpha[, 1:q]
beta  <- diag(rep(1, p))[, 1:q]
###计算 估计的beta和真实beta张成空间的距离
##把beta和beta_hat施密特正交化
span_beta = qr.Q(qr(beta))
span_beta_hat = qr.Q(qr(beta_hat))
##计算距离
dis = q
for (i in 1:q) {
dis = dis - sum((t(span_beta[, i]) %*% span_beta_hat) ^ 2)
}
dis = sqrt(dis)
return(dis)
}
dis_cos_3 <- experiment(20,3,1000)
object <- function(p, q, n) {
#p初始化x维数,q初始化t(beta)作用在X上用的有效维度 n样本量
h = 10
#初始化beta矩阵p*q维
beta  <- diag(rep(1, p))[, 1:q]##是个单位阵，取前p个行向量
X = matrix(nrow = p, ncol = n)
y = rep(0, n)
for (j in 1:n)
{
#按标准正态分布生成每个样本点Xi的每个维度的值 并按不同模型生成y
X[, j] = rnorm(p, 0, 1)
lambda1 = sum(t(beta) %*% X[, j])
lambda2 = exp(sum(t(beta) %*% X[, j]))
lambda3 = exp(sum(t(beta) %*% X[, j])) / (1 + exp(sum(t(beta) %*% X[, j])))
#y[j] = rnorm(1, lambda1, 1) + rnorm(1, 1, 0.1) #正态
#y[j]=rpois(1,lambda2)+rnorm(1,0,0.1)   #泊松
#y[j]=rbinom(1,1,lambda3)++rnorm(1,0,0.1)  #logistic
y[j] = cos(2 * c(t(beta[,1]) %*% X[, j])) + cos(c(t(beta[, 2]) %*% X[, j]))  + cos(c(t(beta[, 3]) %*% X[, j])) +cos(c(t(beta[, 4]) %*% X[, j]))# +cos(c(t(beta[, 5]) %*% X[, j]))
+ rnorm(1, 1, 0.1)
#y[j]=rnorm(1,2*X[2,j],1)+rnorm(1,X[1,j],1)+rnorm(1,0,0.1)
#y[j]=exp(X[1,j])+exp(X[2,j])+rnorm(1,0,0.1)
#y[j]=rpois(1,exp(X[1,j]))+rpois(1,exp(X[2,j]))+rnorm(1,0,0.1)
#y[j]=2*X[2,j]+X[1,j]
#y[j]=exp(X[1,j])/(1+exp(X[1,j]))+exp(X[2,j])/(1+exp(X[2,j]))
}
#标准化X
mu = rowMeans(X)
var = cov(t(X - mu))
lamda = solve(eigen(var)$vectors) %*% var %*% (eigen(var)$vectors)
lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
#y从小到大排序，按该次序对Z进行重排
Zord = Z[, order(y)]
y1 = rep(0, n)
pn = floor(n / h)
y1[1:pn] = 1
for (i in 1:(h - 2)) {
y1[(pn * i + 1):(pn * (i + 1))] = i + 1
}
y1[(pn * (h - 1) + 1):n] = h
#计算M
zmean = matrix(nrow = p, ncol = h)
M = matrix(0, nrow = p, ncol = p)
prob = rep(0, h)
for (i in 1:h) {
prob[i] = length(y1[y1 == i]) / n
M = M + prob[i] * (diag(p) - var(t(Zord[, y1 == i]))) %*% (diag(p) - var(t(Zord[, y1 ==
i])))
}
alpha = eigen(M)$vector
fixq <- function(eigenvalue, n, p) {
cn = 1 / n ^ (1 / 3)
t = rep(0, p - 1)
q_hat = 0
for (i in 1:(p - 1)) {
if ((eigenvalue[i + 1] + cn) / (eigenvalue[i] + cn) <= 0.5)
{
q_hat = i
}
}
return(q_hat)
}
q_hat = fixq(eigen(M)$value, n, p)
beta_hat = sd %*% alpha[, 1:q]
beta  <- diag(rep(1, p))[, 1:q]
###计算 估计的beta和真实beta张成空间的距离
##把beta和beta_hat施密特正交化
span_beta = qr.Q(qr(beta))
span_beta_hat = qr.Q(qr(beta_hat))
##计算距离
dis = q
for (i in 1:q) {
dis = dis - sum((t(span_beta[, i]) %*% span_beta_hat) ^ 2)
}
dis = sqrt(dis)
return(dis)
}
dis_cos_4 <- experiment(20,4,1000)
object <- function(p, q, n) {
#p初始化x维数,q初始化t(beta)作用在X上用的有效维度 n样本量
h = 10
#初始化beta矩阵p*q维
beta  <- diag(rep(1, p))[, 1:q]##是个单位阵，取前p个行向量
X = matrix(nrow = p, ncol = n)
y = rep(0, n)
for (j in 1:n)
{
#按标准正态分布生成每个样本点Xi的每个维度的值 并按不同模型生成y
X[, j] = rnorm(p, 0, 1)
lambda1 = sum(t(beta) %*% X[, j])
lambda2 = exp(sum(t(beta) %*% X[, j]))
lambda3 = exp(sum(t(beta) %*% X[, j])) / (1 + exp(sum(t(beta) %*% X[, j])))
#y[j] = rnorm(1, lambda1, 1) + rnorm(1, 1, 0.1) #正态
#y[j]=rpois(1,lambda2)+rnorm(1,0,0.1)   #泊松
#y[j]=rbinom(1,1,lambda3)++rnorm(1,0,0.1)  #logistic
y[j] = cos(2 * c(t(beta[,1]) %*% X[, j])) + cos(c(t(beta[, 2]) %*% X[, j]))  + cos(c(t(beta[, 3]) %*% X[, j])) +cos(c(t(beta[, 4]) %*% X[, j])) +cos(c(t(beta[, 5]) %*% X[, j]))
+ rnorm(1, 1, 0.1)
#y[j]=rnorm(1,2*X[2,j],1)+rnorm(1,X[1,j],1)+rnorm(1,0,0.1)
#y[j]=exp(X[1,j])+exp(X[2,j])+rnorm(1,0,0.1)
#y[j]=rpois(1,exp(X[1,j]))+rpois(1,exp(X[2,j]))+rnorm(1,0,0.1)
#y[j]=2*X[2,j]+X[1,j]
#y[j]=exp(X[1,j])/(1+exp(X[1,j]))+exp(X[2,j])/(1+exp(X[2,j]))
}
#标准化X
mu = rowMeans(X)
var = cov(t(X - mu))
lamda = solve(eigen(var)$vectors) %*% var %*% (eigen(var)$vectors)
lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
#y从小到大排序，按该次序对Z进行重排
Zord = Z[, order(y)]
y1 = rep(0, n)
pn = floor(n / h)
y1[1:pn] = 1
for (i in 1:(h - 2)) {
y1[(pn * i + 1):(pn * (i + 1))] = i + 1
}
y1[(pn * (h - 1) + 1):n] = h
#计算M
zmean = matrix(nrow = p, ncol = h)
M = matrix(0, nrow = p, ncol = p)
prob = rep(0, h)
for (i in 1:h) {
prob[i] = length(y1[y1 == i]) / n
M = M + prob[i] * (diag(p) - var(t(Zord[, y1 == i]))) %*% (diag(p) - var(t(Zord[, y1 ==
i])))
}
alpha = eigen(M)$vector
fixq <- function(eigenvalue, n, p) {
cn = 1 / n ^ (1 / 3)
t = rep(0, p - 1)
q_hat = 0
for (i in 1:(p - 1)) {
if ((eigenvalue[i + 1] + cn) / (eigenvalue[i] + cn) <= 0.5)
{
q_hat = i
}
}
return(q_hat)
}
q_hat = fixq(eigen(M)$value, n, p)
beta_hat = sd %*% alpha[, 1:q]
beta  <- diag(rep(1, p))[, 1:q]
###计算 估计的beta和真实beta张成空间的距离
##把beta和beta_hat施密特正交化
span_beta = qr.Q(qr(beta))
span_beta_hat = qr.Q(qr(beta_hat))
##计算距离
dis = q
for (i in 1:q) {
dis = dis - sum((t(span_beta[, i]) %*% span_beta_hat) ^ 2)
}
dis = sqrt(dis)
return(dis)
}
dis_cos_5 <- experiment(20,5,1000)
dis <- data.frame(dim,dis_cos,dis_cos_2,dis_cos_3,dis_cos_4,dis_cos_5)
ggplot(data=dis)+geom_point(aes(dim,dis_cos,colour='1'))+geom_point(aes(dim,dis_cos_2,colour="2"))+geom_point(aes(dim,dis_cos_3,colour="3"))
library(ggplot2)
ggplot(data=dis)+geom_point(aes(dim,dis_cos,colour='1'))+geom_point(aes(dim,dis_cos_2,colour="2"))+geom_point(aes(dim,dis_cos_3,colour="3"))
ggplot(data=dis)+geom_line(aes(dim,dis_cos,colour='1'))+geom_line(aes(dim,dis_cos_2,colour="2"))+geom_line(aes(dim,dis_cos_3,colour="3"))
+geom_line(aes(dim,dis_cos_4,colour="4"))+geom_line(aes(dim,dis_cos_5,colour="5"))
ggplot
ggplot(data=dis)+geom_line(aes(dim,dis_cos_3,colour="3"))
ggplot(data=dis)+geom_point(aes(dim,dis_cos,colour='1'))+geom_point(aes(dim,dis_cos_2,colour="2"))+geom_point(aes(dim,dis_cos_3,colour="3"))+geom_point(aes(dim,dis_cos_4,colour="4"))+geom_point(aes(dim,dis_cos_5,colour="5"))
ggplot(data=dis)+geom_line(aes(dim,dis_cos,colour='1'))+geom_line(aes(dim,dis_cos_2,colour="2"))+geom_line(aes(dim,dis_cos_3,colour="3"))+geom_line(aes(dim,dis_cos_4,colour="4"))+geom_line(aes(dim,dis_cos_5,colour="5"))
object(10,1000)
source('E:/Github/2020_high_dimension/第一次作业/code/ols norm.R', encoding = 'UTF-8', echo=TRUE)
object<-function(p,n,coef){
beta = rep(1,p)
X=matrix(nrow=p,ncol=n)
y = rep(0,n)
for(j in 1:n)
{
X[,j]=runif(p,min=-1,max=1)
lambda=exp(beta%*%X[,j])/(1+exp(beta%*%X[,j]))
y[j]=rbinom(1,1,lambda)+rnorm(1,0,1)
}
EXY=X%*%y/n
coef=coef
C=NEWTON(coef,X,y,n,EXY)
EXY*C
return(EXY*C)
}
object(10,1000)
object(10,1000,2)
l<-function(coef,X,y,n,EXY){
f1=0
f2=0
for(i in 1:n){
f1 = f1 +2*t(EXY)%*%X[,i]*exp(-t(EXY)%*%X[,i]*coef)/(1+exp(-t(EXY)%*%X[,i]*coef))^2*
(y[i]-1/(1+exp(-t(EXY)%*%X[,i]*coef)))
f2 = f2 + 2*(-(t(EXY)%*%X[,i]*exp(-t(EXY)%*%X[,i]*coef)/(1+exp(-t(EXY)%*%X[,i]*coef))^2)^2+
(y[i]-1/(1+exp(-t(EXY)%*%X[,i]*coef)))*(((t(EXY)%*%X[,i])^2*exp(-t(EXY)%*%X[,i]*coef)*
(1-exp(-t(EXY)%*%X[,i]*coef))/(1+exp(-t(EXY)%*%X[,i]*coef))^3)))
}
return(f1/f2)
}
NEWTON<-function(coef,X,y,n,EXY){
eta=1e-10
for(i in 1:100){
a=coef
b=coef-l(coef,X,y,n,EXY)
if(abs(a-b)<=eta){
break;
}
else{
a=b
coef=b
}
}
return(c(coef))
}
set.seed(1)
object<-function(p,n,coef){
beta = rep(1,p)
X=matrix(nrow=p,ncol=n)
y = rep(0,n)
for(j in 1:n)
{
X[,j]=runif(p,min=-1,max=1)
lambda=exp(beta%*%X[,j])/(1+exp(beta%*%X[,j]))
y[j]=rbinom(1,1,lambda)+rnorm(1,0,1)
}
EXY=X%*%y/n
coef=coef
C=NEWTON(coef,X,y,n,EXY)
EXY*C
return(EXY*C)
}
object(10,1000,2)
#计算目标函数对c一阶偏导与二阶偏导的比值
l<-function(coef,X,y,n,EXY){
f1=0
f2=0
for(i in 1:n){
f1=f1-2*t(EXY)%*%X[,i]*(y[i]-exp(t(EXY)%*%X[,i]*coef))*exp(t(EXY)%*%X[,i]*coef)
f2=f2-2*(t(EXY)%*%X[,i])^(2)*y[i]*exp(t(EXY)%*%X[,i]*coef)+4*(t(EXY)%*%X[,i])^(2)*exp(2*t(EXY)%*%X[,i]*coef)
}
return(f1/f2)
}
#牛顿迭代主体部分
NEWTON<-function(coef,X,y,n,EXY){
eta=1e-10
for(i in 1:100){
a=coef
b=coef-l(coef,X,y,n,EXY)
if(abs(a-b)<=eta){
break;
}
else{
a=b
coef=b
}
}
return(c(coef))
}
#初始化beta，设定样本维度，大小，并给一个c的初值进行迭代
object<-function(p,n,coef){
beta = rep(1,p)
X=matrix(nrow=p,ncol=n)
y = rep(0,n)
for(j in 1:n)
{
X[,j]=runif(p,min=-1,max=1)
lambda=exp(beta%*%X[,j])
y[j]=rpois(1,lambda)+rnorm(1,0,1)
}
EXY=X%*%y/n
coef=coef
C=NEWTON(coef,X,y,n,EXY)
EXY*C
return(EXY*C)
}
object(10,1000,2)
a <- matrix(c(0.9,0.7,0.1,0.3),byrow=TRUE, nrow=2, ncol=2)
a%*%a
a%*%a%*%a
a %^% 3
matpower=function(a,alpha){
a=(a+t(a))/2;tmp=eigen(a)
return(tmp$vectors%*%diag((tmp$values)^alpha)%*%t(tmp$vectors))}
matpower(a,3)
matpower=function(a,alpha){
tmp=eigen(a)
return(tmp$vectors%*%diag((tmp$values)^alpha)%*%t(tmp$vectors))}
matpower(a,3)
p=10
q=2
n=100
#p初始化x维数,q初始化t(beta)作用在X上用的有效维度 n样本量
#初始化beta矩阵p*q维
beta  <- diag(rep(1, p))[, 1:q]##是个单位阵，取前p个行向量
X = matrix(nrow = p, ncol = n)
y = rep(0, n)
for (j in 1:n)
{
#按标准正态分布生成每个样本点Xi的每个维度的值 并按不同模型生成y
X[, j] = rnorm(p, 0, 1)
lambda1 = sum(t(beta) %*% X[, j])
lambda2 = exp(sum(t(beta) %*% X[, j]))
lambda3 = exp(sum(t(beta) %*% X[, j])) / (1 + exp(sum(t(beta) %*% X[, j])))
#y[j]=rnorm(1,lambda1,1)+rnorm(1,1,0.1) #正态
#y[j]=rpois(1,lambda2)+rnorm(1,0,0.1)   #泊松
#y[j]=rbinom(1,1,lambda3)++rnorm(1,0,0.1)  #logistic
y[j] = cos(2 * c(t(beta[, 1]) %*% X[, j])) + cos(c(t(beta[, 2]) %*% X[, j])) +
rnorm(1, 1, 0.1)
#y[j]=rnorm(1,2*X[2,j],1)+rnorm(1,X[1,j],1)+rnorm(1,0,0.1)
#y[j]=exp(X[1,j])+exp(X[2,j])+rnorm(1,0,0.1)
#y[j]=rpois(1,exp(X[1,j]))+rpois(1,exp(X[2,j]))+rnorm(1,0,0.1)
#y[j]=2*X[2,j]+X[1,j]
#y[j]=exp(X[1,j])/(1+exp(X[1,j]))+exp(X[2,j])/(1+exp(X[2,j]))
}
#中心化标准化
mu = rowMeans(X)
var = cov(t(X - mu))
lamda = solve(eigen(var)$vectors) %*% var %*% (eigen(var)$vectors)
lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
y = y - mean(y)
y = c(y)
a = Z %*% y / n
a
apply(X,2,mean)
help("cbind")
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
M1
beta  <- diag(rep(1, p))[, 1:q]##是个单位阵，取前p个行向量
X = matrix(nrow = p, ncol = n)
y = rep(0, n)
for (j in 1:n)
{
#按标准正态分布生成每个样本点Xi的每个维度的值 并按不同模型生成y
X[, j] = rnorm(p, 0, 1)
lambda1 = sum(t(beta) %*% X[, j])
lambda2 = exp(sum(t(beta) %*% X[, j]))
lambda3 = exp(sum(t(beta) %*% X[, j])) / (1 + exp(sum(t(beta) %*% X[, j])))
#y[j]=rnorm(1,lambda1,1)+rnorm(1,1,0.1) #正态
#y[j]=rpois(1,lambda2)+rnorm(1,0,0.1)   #泊松
#y[j]=rbinom(1,1,lambda3)++rnorm(1,0,0.1)  #logistic
y[j] = cos(2 * c(t(beta[, 1]) %*% X[, j])) + cos(c(t(beta[, 2]) %*% X[, j])) +
rnorm(1, 1, 0.1)
#y[j]=rnorm(1,2*X[2,j],1)+rnorm(1,X[1,j],1)+rnorm(1,0,0.1)
#y[j]=exp(X[1,j])+exp(X[2,j])+rnorm(1,0,0.1)
#y[j]=rpois(1,exp(X[1,j]))+rpois(1,exp(X[2,j]))+rnorm(1,0,0.1)
#y[j]=2*X[2,j]+X[1,j]
#y[j]=exp(X[1,j])/(1+exp(X[1,j]))+exp(X[2,j])/(1+exp(X[2,j]))
}
#中心化标准化
mu = rowMeans(X)
var = cov(t(X - mu))
lamda = solve(eigen(var)$vectors) %*% var %*% (eigen(var)$vectors)
lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
y = y - mean(y)
y = c(y)
#计算H1，H2
H1 = matrix(0, nrow = p, ncol = p)
H2 = matrix(0, nrow = p, ncol = p)
a = Z %*% y / n
H1 = t(t(Z) * (y - mean(y))) %*% t(Z) / n
H2 = t(t(Z) * (y - mean(y) - c(t(a) %*% Z))) %*% t(Z) / n
M1= Z%*%y/n
M2=Z%*%y/n
H1%*%M1
for(i in 1:(p-1)){
M1=rbind(M1,H1%*%M1)
H1=H1%*%H1
}
H1=H1%*%H1
H1 = t(t(Z) * (y - mean(y))) %*% t(Z) / n
H2 = t(t(Z) * (y - mean(y) - c(t(a) %*% Z))) %*% t(Z) / n
M1= Z%*%y/n
M2=Z%*%y/n
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
M1= Z%*%y/n
M2=Z%*%y/n
for(i in 1:(p-1)){
M1=rbind(M1,H1%*%a)
H1=H1%*%H1
}
M1
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
eigen(M1 %*% t(M1))
M1
for(i in 1:(p-1)){
M1=cbind(M1,H1%*%a)
H1=H1%*%H1
}
a = Z %*% y / n
H1 = t(t(Z) * (y - mean(y))) %*% t(Z) / n
H2 = t(t(Z) * (y - mean(y) - c(t(a) %*% Z))) %*% t(Z) / n
M1= Z%*%y/n
M2=Z%*%y/n
for(i in 1:(p-1)){
M1=cbind(M1,H1%*%a)
H1=H1%*%H1
}
H1 = matrix(0, nrow = p, ncol = p)
H2 = matrix(0, nrow = p, ncol = p)
a = Z %*% y / n
H1 = t(t(Z) * (y - mean(y))) %*% t(Z) / n
H2 = t(t(Z) * (y - mean(y) - c(t(a) %*% Z))) %*% t(Z) / n
M1= Z%*%y/n
M2=Z%*%y/n
for(i in 1:(p-1)){
M1=cbind(M1,H1%*%a)
H1=H1%*%H1
}
M1
eigen(M1 %*% t(M1))
iht=function(x,y,r){
matpower=function(a,alpha){
a=(a+t(a))/2;tmp=eigen(a)
return(tmp$vectors%*%diag((tmp$values)^alpha)%*%t(tmp$vectors))}
standmat=function(x){
mu=apply(x,2,mean);sig=var(x);signrt=matpower(sig,-1/2)
return(t(t(x)-mu)%*%signrt)}
z=standmat(x);szy=cov(z,y);szz=var(z);p=dim(z)[2];imat=szy
for(i in 1:(p-1)) imat=cbind(imat,matpower(szz,i)%*%szy)
return(eigen(imat%*%t(imat))$vectors[,1:r])}
iht(t(X),y,2)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
iht=function(x,y,r){
matpower=function(a,alpha){
a=(a+t(a))/2;tmp=eigen(a)
return(tmp$vectors%*%diag((tmp$values)^alpha)%*%t(tmp$vectors))}
standmat=function(x){
mu=apply(x,2,mean);sig=var(x);signrt=matpower(sig,-1/2)
return(t(t(x)-mu)%*%signrt)}
z=standmat(x);szy=cov(z,y);szz=var(z);p=dim(z)[2];imat=szy
for(i in 1:(p-1)) imat=cbind(imat,matpower(szz,i)%*%szy)
return(matpower(sig,-1/2)%*%eigen(imat%*%t(imat))$vectors[,1:r])}
iht(t(X),y,2)
iht=function(x,y,r){
matpower=function(a,alpha){
a=(a+t(a))/2;tmp=eigen(a)
return(tmp$vectors%*%diag((tmp$values)^alpha)%*%t(tmp$vectors))}
standmat=function(x){
mu=apply(x,2,mean);sig=var(x);signrt=matpower(sig,-1/2)
return(t(t(x)-mu)%*%signrt)}
z=standmat(x);szy=cov(z,y);szz=var(z);p=dim(z)[2];imat=szy
for(i in 1:(p-1)) imat=cbind(imat,matpower(szz,i)%*%szy)
return(matpower(var(x),-1/2)%*%eigen(imat%*%t(imat))$vectors[,1:r])}
iht(t(X),y,2)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/phd.R', encoding = 'UTF-8', echo=TRUE)
