lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
y = y - mean(y)
y = c(y)
a = Z %*% y / n
a
apply(X,2,mean)
help("cbind")
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
M1
beta  <- diag(rep(1, p))[, 1:q]##是个单位阵，取前p个行向量
X = matrix(nrow = p, ncol = n)
y = rep(0, n)
for (j in 1:n)
{
#按标准正态分布生成每个样本点Xi的每个维度的值 并按不同模型生成y
X[, j] = rnorm(p, 0, 1)
lambda1 = sum(t(beta) %*% X[, j])
lambda2 = exp(sum(t(beta) %*% X[, j]))
lambda3 = exp(sum(t(beta) %*% X[, j])) / (1 + exp(sum(t(beta) %*% X[, j])))
#y[j]=rnorm(1,lambda1,1)+rnorm(1,1,0.1) #正态
#y[j]=rpois(1,lambda2)+rnorm(1,0,0.1)   #泊松
#y[j]=rbinom(1,1,lambda3)++rnorm(1,0,0.1)  #logistic
y[j] = cos(2 * c(t(beta[, 1]) %*% X[, j])) + cos(c(t(beta[, 2]) %*% X[, j])) +
rnorm(1, 1, 0.1)
#y[j]=rnorm(1,2*X[2,j],1)+rnorm(1,X[1,j],1)+rnorm(1,0,0.1)
#y[j]=exp(X[1,j])+exp(X[2,j])+rnorm(1,0,0.1)
#y[j]=rpois(1,exp(X[1,j]))+rpois(1,exp(X[2,j]))+rnorm(1,0,0.1)
#y[j]=2*X[2,j]+X[1,j]
#y[j]=exp(X[1,j])/(1+exp(X[1,j]))+exp(X[2,j])/(1+exp(X[2,j]))
}
#中心化标准化
mu = rowMeans(X)
var = cov(t(X - mu))
lamda = solve(eigen(var)$vectors) %*% var %*% (eigen(var)$vectors)
lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
y = y - mean(y)
y = c(y)
#计算H1，H2
H1 = matrix(0, nrow = p, ncol = p)
H2 = matrix(0, nrow = p, ncol = p)
a = Z %*% y / n
H1 = t(t(Z) * (y - mean(y))) %*% t(Z) / n
H2 = t(t(Z) * (y - mean(y) - c(t(a) %*% Z))) %*% t(Z) / n
M1= Z%*%y/n
M2=Z%*%y/n
H1%*%M1
for(i in 1:(p-1)){
M1=rbind(M1,H1%*%M1)
H1=H1%*%H1
}
H1=H1%*%H1
H1 = t(t(Z) * (y - mean(y))) %*% t(Z) / n
H2 = t(t(Z) * (y - mean(y) - c(t(a) %*% Z))) %*% t(Z) / n
M1= Z%*%y/n
M2=Z%*%y/n
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
M1= Z%*%y/n
M2=Z%*%y/n
for(i in 1:(p-1)){
M1=rbind(M1,H1%*%a)
H1=H1%*%H1
}
M1
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
eigen(M1 %*% t(M1))
M1
for(i in 1:(p-1)){
M1=cbind(M1,H1%*%a)
H1=H1%*%H1
}
a = Z %*% y / n
H1 = t(t(Z) * (y - mean(y))) %*% t(Z) / n
H2 = t(t(Z) * (y - mean(y) - c(t(a) %*% Z))) %*% t(Z) / n
M1= Z%*%y/n
M2=Z%*%y/n
for(i in 1:(p-1)){
M1=cbind(M1,H1%*%a)
H1=H1%*%H1
}
H1 = matrix(0, nrow = p, ncol = p)
H2 = matrix(0, nrow = p, ncol = p)
a = Z %*% y / n
H1 = t(t(Z) * (y - mean(y))) %*% t(Z) / n
H2 = t(t(Z) * (y - mean(y) - c(t(a) %*% Z))) %*% t(Z) / n
M1= Z%*%y/n
M2=Z%*%y/n
for(i in 1:(p-1)){
M1=cbind(M1,H1%*%a)
H1=H1%*%H1
}
M1
eigen(M1 %*% t(M1))
iht=function(x,y,r){
matpower=function(a,alpha){
a=(a+t(a))/2;tmp=eigen(a)
return(tmp$vectors%*%diag((tmp$values)^alpha)%*%t(tmp$vectors))}
standmat=function(x){
mu=apply(x,2,mean);sig=var(x);signrt=matpower(sig,-1/2)
return(t(t(x)-mu)%*%signrt)}
z=standmat(x);szy=cov(z,y);szz=var(z);p=dim(z)[2];imat=szy
for(i in 1:(p-1)) imat=cbind(imat,matpower(szz,i)%*%szy)
return(eigen(imat%*%t(imat))$vectors[,1:r])}
iht(t(X),y,2)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
iht=function(x,y,r){
matpower=function(a,alpha){
a=(a+t(a))/2;tmp=eigen(a)
return(tmp$vectors%*%diag((tmp$values)^alpha)%*%t(tmp$vectors))}
standmat=function(x){
mu=apply(x,2,mean);sig=var(x);signrt=matpower(sig,-1/2)
return(t(t(x)-mu)%*%signrt)}
z=standmat(x);szy=cov(z,y);szz=var(z);p=dim(z)[2];imat=szy
for(i in 1:(p-1)) imat=cbind(imat,matpower(szz,i)%*%szy)
return(matpower(sig,-1/2)%*%eigen(imat%*%t(imat))$vectors[,1:r])}
iht(t(X),y,2)
iht=function(x,y,r){
matpower=function(a,alpha){
a=(a+t(a))/2;tmp=eigen(a)
return(tmp$vectors%*%diag((tmp$values)^alpha)%*%t(tmp$vectors))}
standmat=function(x){
mu=apply(x,2,mean);sig=var(x);signrt=matpower(sig,-1/2)
return(t(t(x)-mu)%*%signrt)}
z=standmat(x);szy=cov(z,y);szz=var(z);p=dim(z)[2];imat=szy
for(i in 1:(p-1)) imat=cbind(imat,matpower(szz,i)%*%szy)
return(matpower(var(x),-1/2)%*%eigen(imat%*%t(imat))$vectors[,1:r])}
iht(t(X),y,2)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('G:/GitHub/2020_high_dimension/第一次作业/code/IHT.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/phd.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
library(ggplot2)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
object <- function(p, q, n) {
#p初始化x维数,q初始化t(beta)作用在X上用的有效维度 n样本量
h = ceiling(sqrt(n))
#初始化beta矩阵m*p维
beta  <- diag(rep(1, p))[, 1:q]##是个单位阵，取前p个行向量
X = matrix(nrow = p, ncol = n)
y = rep(0, n)
for (j in 1:n)
{
#按标准正态分布生成每个样本点Xi的每个维度的值 并按不同模型生成y
X[, j] = rnorm(p, 0, 1)
lambda1 = sum(t(beta) %*% X[, j])
lambda2 = exp(sum(t(beta) %*% X[, j]))
lambda3 = exp(sum(t(beta) %*% X[, j])) / (1 + exp(sum(t(beta) %*% X[, j])))
#y[j] = rnorm(1, lambda1, 1) + rnorm(1, 1, 0.1) #正态
#y[j]=rpois(1,lambda2)+rnorm(1,0,0.1)   #泊松
#y[j]=rbinom(1,1,lambda3)++rnorm(1,0,0.1)  #logistic
y[j] = sin(2 * c(t(beta) %*% X[, j]))#  + sin(c(t(beta[, 2]) %*% X[, j]))
#+ rnorm(1, 1, 0.1)
#y[j]=rnorm(1,2*X[2,j],1)+rnorm(1,X[1,j],1)+rnorm(1,0,0.1)
#y[j]=exp(X[1,j])+exp(X[2,j])+rnorm(1,0,0.1)
#y[j]=rpois(1,exp(X[1,j]))+rpois(1,exp(X[2,j]))+rnorm(1,0,0.1)
#y[j]=2*X[2,j]+X[1,j]
#y[j]=exp(X[1,j])/(1+exp(X[1,j]))+exp(X[2,j])/(1+exp(X[2,j]))
}
#标准化X
mu = rowMeans(X)
var = cov(t(X - mu))
lamda = solve(eigen(var)$vectors) %*% var %*% (eigen(var)$vectors)
lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
#y从小到大排序，按该次序对Z进行重排
Zord = Z[, order(y)]
y1 = rep(0, n)
pn = floor(n / h)
y1[1:pn] = 1
for (i in 1:(h - 2)) {
y1[(pn * i + 1):(pn * (i + 1))] = i + 1
}
y1[(pn * (h - 1) + 1):n] = h
#计算M
g = matrix(nrow = p, ncol = h)
prob = rep(0, h)
for (i in 1:h) {
prob[i] = length(y1[y1 == i]) / n
g[, i] = apply(Zord[, y1 == i], 1, mean)
}
M = g %*% diag(prob) %*% t(g)
alpha = eigen(M)$vector
beta_hat = sd %*% alpha[, 1:q]
###计算 估计的beta和真实beta张成空间的距离
##把beta和beta_hat施密特正交化
span_beta = qr.Q(qr(beta))
span_beta_hat = qr.Q(qr(beta_hat))
# ##计算距离
dis = q
for (i in 1:q) {
dis = dis - sum((t(span_beta[, i]) %*% span_beta_hat) ^ 2)
}
dis = sqrt(dis)
return(dis)
}
# object(10,2,1000)
experiment <-function(dim_x,dim_r,n){
dis <- rep(0,11)
for (i in 1:11){
for(i in 1:100){
dis[i] <- object(i+9,dim_r,n)/100
}
}
dim <- rep(10:20)
dis <- data.frame(dim,dis)
return(dis)
}
ggplot(data=dis,aes(x=dim,y=dis))+geom_line(linetype="dotted")+geom_point(size=4, shape=20)
dis <- experiment(20,1,1000)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
matpower = function(a,alpha){
a = round((a + t(a))/2,7); tmp = eigen(a)
return(tmp$vectors%*%diag((tmp$values)^alpha)%*%t(tmp$vectors))}
discretize=function(y,h){
n=length(y);m=floor(n/h)
y=y+.00001*mean(y)*rnorm(n)
yord = y[order(y)]
divpt=numeric();for(i in 1:(h-1)) divpt = c(divpt,yord[i*m+1])
y1=rep(0,n);y1[y<divpt[1]]=1;y1[y>=divpt[h-1]]=h
for(i in 2:(h-1)) y1[(y>=divpt[i-1])&(y<divpt[i])]=i
return(y1)}
sir=function(x,y,h,r,ytype){
p=ncol(x);n=nrow(x)
signrt=matpower(var(x),-1/2)
xc=t(t(x)-apply(x,2,mean))
xst=xc%*%signrt
if(ytype=="continuous") ydis=discretize(y,h)
if(ytype=="categorical") ydis=y
yless=ydis;ylabel=numeric()
for(i in 1:n) {if(var(yless)!=0) {ylabel=
c(ylabel,yless[1]);yless=yless[yless!=yless[1]]}}
ylabel=c(ylabel,yless[1])
prob=numeric();exy=numeric()
for(i in 1:h) prob=c(prob,length(ydis[ydis==ylabel[i]])/n)
for(i in 1:h) exy=rbind(exy,apply(xst[ydis==ylabel[i],],2,mean))
sirmat=t(exy)%*%diag(prob)%*%exy
return(signrt%*%eigen(sirmat)$vectors[,1:r])}
library(ggplot2)
object <- function(p, q, n) {
#p初始化x维数,q初始化t(beta)作用在X上用的有效维度 n样本量
h = ceiling(sqrt(n))
#初始化beta矩阵m*p维
beta  <- diag(rep(1, p))[, 1:q]##是个单位阵，取前p个行向量
X = matrix(nrow = p, ncol = n)
y = rep(0, n)
for (j in 1:n)
{
#按标准正态分布生成每个样本点Xi的每个维度的值 并按不同模型生成y
X[, j] = rnorm(p, 0, 1)
lambda1 = sum(t(beta) %*% X[, j])
lambda2 = exp(sum(t(beta) %*% X[, j]))
lambda3 = exp(sum(t(beta) %*% X[, j])) / (1 + exp(sum(t(beta) %*% X[, j])))
y[j] = rnorm(1, lambda1, 1) + rnorm(1, 1, 0.1) #正态
#y[j]=rpois(1,lambda2)+rnorm(1,0,0.1)   #泊松
#y[j]=rbinom(1,1,lambda3)++rnorm(1,0,0.1)  #logistic
# y[j] = sin(2 * c(t(beta[,1]) %*% X[, j]))  + sin(c(t(beta[, 2]) %*% X[, j]))
#+ rnorm(1, 1, 0.1)
#y[j]=rnorm(1,2*X[2,j],1)+rnorm(1,X[1,j],1)+rnorm(1,0,0.1)
#y[j]=exp(X[1,j])+exp(X[2,j])+rnorm(1,0,0.1)
#y[j]=rpois(1,exp(X[1,j]))+rpois(1,exp(X[2,j]))+rnorm(1,0,0.1)
#y[j]=2*X[2,j]+X[1,j]
#y[j]=exp(X[1,j])/(1+exp(X[1,j]))+exp(X[2,j])/(1+exp(X[2,j]))
}
#标准化X
mu = rowMeans(X)
var = cov(t(X - mu))
lamda = solve(eigen(var)$vectors) %*% var %*% (eigen(var)$vectors)
lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
#y从小到大排序，按该次序对Z进行重排
Zord = Z[, order(y)]
y1 = rep(0, n)
pn = floor(n / h)
y1[1:pn] = 1
for (i in 1:(h - 2)) {
y1[(pn * i + 1):(pn * (i + 1))] = i + 1
}
y1[(pn * (h - 1) + 1):n] = h
#计算M
g = matrix(nrow = p, ncol = h)
prob = rep(0, h)
for (i in 1:h) {
prob[i] = length(y1[y1 == i]) / n
g[, i] = apply(Zord[, y1 == i], 1, mean)
}
M = g %*% diag(prob) %*% t(g)
alpha = eigen(M)$vector
alpha=sir(t(X),y,h,q,"continous")
beta_hat = sd %*% alpha[, 1:q]
###计算 估计的beta和真实beta张成空间的距离
##把beta和beta_hat施密特正交化
span_beta = qr.Q(qr(beta))
span_beta_hat = qr.Q(qr(beta_hat))
# ##计算距离
dis = q
for (i in 1:q) {
dis = dis - sum((t(span_beta[, i]) %*% span_beta_hat) ^ 2)
}
dis = sqrt(dis)
return(dis)
}
object(10,2,1000)
View(sir)
discretize=function(y,h){
n=length(y);m=floor(n/h)
y=y+.00001*mean(y)*rnorm(n)
yord = y[order(y)]
divpt=numeric();for(i in 1:(h-1)) divpt = c(divpt,yord[i*m+1])
y1=rep(0,n);y1[y<divpt[1]]=1;y1[y>=divpt[h-1]]=h
for(i in 2:(h-1)) y1[(y>=divpt[i-1])&(y<divpt[i])]=i
return(y1)}
p=20
q=2
n=1000
h = ceiling(sqrt(n))
#初始化beta矩阵m*p维
beta  <- diag(rep(1, p))[, 1:q]##是个单位阵，取前p个行向量
X = matrix(nrow = p, ncol = n)
y = rep(0, n)
for (j in 1:n)
{
#按标准正态分布生成每个样本点Xi的每个维度的值 并按不同模型生成y
X[, j] = rnorm(p, 0, 1)
lambda1 = sum(t(beta) %*% X[, j])
lambda2 = exp(sum(t(beta) %*% X[, j]))
lambda3 = exp(sum(t(beta) %*% X[, j])) / (1 + exp(sum(t(beta) %*% X[, j])))
y[j] = rnorm(1, lambda1, 1) + rnorm(1, 1, 0.1) #正态
#y[j]=rpois(1,lambda2)+rnorm(1,0,0.1)   #泊松
#y[j]=rbinom(1,1,lambda3)++rnorm(1,0,0.1)  #logistic
# y[j] = sin(2 * c(t(beta[,1]) %*% X[, j]))  + sin(c(t(beta[, 2]) %*% X[, j]))
#+ rnorm(1, 1, 0.1)
#y[j]=rnorm(1,2*X[2,j],1)+rnorm(1,X[1,j],1)+rnorm(1,0,0.1)
#y[j]=exp(X[1,j])+exp(X[2,j])+rnorm(1,0,0.1)
#y[j]=rpois(1,exp(X[1,j]))+rpois(1,exp(X[2,j]))+rnorm(1,0,0.1)
#y[j]=2*X[2,j]+X[1,j]
#y[j]=exp(X[1,j])/(1+exp(X[1,j]))+exp(X[2,j])/(1+exp(X[2,j]))
}
#标准化X
mu = rowMeans(X)
var = cov(t(X - mu))
lamda = solve(eigen(var)$vectors) %*% var %*% (eigen(var)$vectors)
lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
#y从小到大排序，按该次序对Z进行重排
Zord = Z[, order(y)]
y1 = rep(0, n)
pn = floor(n / h)
y1[1:pn] = 1
for (i in 1:(h - 2)) {
y1[(pn * i + 1):(pn * (i + 1))] = i + 1
}
y1[(pn * (h - 1) + 1):n] = h
#计算M
g = matrix(nrow = p, ncol = h)
prob = rep(0, h)
for (i in 1:h) {
prob[i] = length(y1[y1 == i]) / n
g[, i] = apply(Zord[, y1 == i], 1, mean)
}
M = g %*% diag(prob) %*% t(g)
alpha = eigen(M)$vector
sir(t(X),y,h,q,"continous")
sir(t(X),y,h,q,"continuous")
object(10,2,1000)
sir(t(X),y,h,q,"continuous")
alpha=sir(t(X),y,h,q,"continuous")
for (i in 1:q) {
dis = dis - sum((t(span_beta[, i]) %*% span_beta_hat) ^ 2)
}
dis = sqrt(dis)
return(dis)
span_beta = qr.Q(qr(beta))
span_beta_hat = qr.Q(qr(beta_hat))
# ##计算距离
dis = q
for (i in 1:q) {
dis = dis - sum((t(span_beta[, i]) %*% span_beta_hat) ^ 2)
}
dis = sqrt(dis)
object(10,2,1000)
library(ggplot2)
object <- function(p, q, n) {
#p初始化x维数,q初始化t(beta)作用在X上用的有效维度 n样本量
h = ceiling(sqrt(n))
#初始化beta矩阵m*p维
beta  <- diag(rep(1, p))[, 1:q]##是个单位阵，取前p个行向量
X = matrix(nrow = p, ncol = n)
y = rep(0, n)
for (j in 1:n)
{
#按标准正态分布生成每个样本点Xi的每个维度的值 并按不同模型生成y
X[, j] = rnorm(p, 0, 1)
lambda1 = sum(t(beta) %*% X[, j])
lambda2 = exp(sum(t(beta) %*% X[, j]))
lambda3 = exp(sum(t(beta) %*% X[, j])) / (1 + exp(sum(t(beta) %*% X[, j])))
y[j] = rnorm(1, lambda1, 1) + rnorm(1, 1, 0.1) #正态
#y[j]=rpois(1,lambda2)+rnorm(1,0,0.1)   #泊松
#y[j]=rbinom(1,1,lambda3)++rnorm(1,0,0.1)  #logistic
# y[j] = sin(2 * c(t(beta[,1]) %*% X[, j]))  + sin(c(t(beta[, 2]) %*% X[, j]))
#+ rnorm(1, 1, 0.1)
#y[j]=rnorm(1,2*X[2,j],1)+rnorm(1,X[1,j],1)+rnorm(1,0,0.1)
#y[j]=exp(X[1,j])+exp(X[2,j])+rnorm(1,0,0.1)
#y[j]=rpois(1,exp(X[1,j]))+rpois(1,exp(X[2,j]))+rnorm(1,0,0.1)
#y[j]=2*X[2,j]+X[1,j]
#y[j]=exp(X[1,j])/(1+exp(X[1,j]))+exp(X[2,j])/(1+exp(X[2,j]))
}
#标准化X
mu = rowMeans(X)
var = cov(t(X - mu))
lamda = solve(eigen(var)$vectors) %*% var %*% (eigen(var)$vectors)
lamda_sqrt <- diag(sqrt(diag(lamda)))
var_sqrt <-
(eigen(var)$vectors) %*% lamda_sqrt %*% solve(eigen(var)$vectors)
sd = solve(var_sqrt)
Z = sd %*% (X - mu)
#y从小到大排序，按该次序对Z进行重排
Zord = Z[, order(y)]
y1 = rep(0, n)
pn = floor(n / h)
y1[1:pn] = 1
for (i in 1:(h - 2)) {
y1[(pn * i + 1):(pn * (i + 1))] = i + 1
}
y1[(pn * (h - 1) + 1):n] = h
#计算M
g = matrix(nrow = p, ncol = h)
prob = rep(0, h)
for (i in 1:h) {
prob[i] = length(y1[y1 == i]) / n
g[, i] = apply(Zord[, y1 == i], 1, mean)
}
M = g %*% diag(prob) %*% t(g)
alpha = eigen(M)$vector
alpha=sir(t(X),y,h,q,"continuous")
beta_hat = sd %*% alpha[, 1:q]
###计算 估计的beta和真实beta张成空间的距离
##把beta和beta_hat施密特正交化
span_beta = qr.Q(qr(beta))
span_beta_hat = qr.Q(qr(beta_hat))
# ##计算距离
dis = q
for (i in 1:q) {
dis = dis - sum((t(span_beta[, i]) %*% span_beta_hat) ^ 2)
}
dis = sqrt(dis)
return(dis)
}
object(10,2,1000)
experiment <-function(dim_x,dim_r,n){
dis <- rep(0,11)
for (i in 1:11){
for(j in 1:100){
dis[i] <-dis[i]+  object(i+9,dim_r,n)/100
}
}
dim <- rep(10:20)
dis <- data.frame(dim,dis)
return(dis)
}
dis <- experiment(20,2,1000)
#dis_cos <- experiment(20,1,1000)
#dis_sin <- experiment(20,1,1000)
#dim <- rep(10:20)
#dis <- data.frame(dim,dis_sin,dis_cos)
# ggplot(data=dis)+geom_point(aes(dim,dis_cos,colour='cos'))+geom_point(aes(dim,dis_sin,colour="sin"))
ggplot(data=dis,aes(x=dim,y=dis))+geom_line(linetype="dotted")+geom_point(size=4, shape=20)
source('E:/Github/2020_high_dimension/第一次作业/code/SIR.R', encoding = 'UTF-8', echo=TRUE)
